from pathlib import Path

import wandb
from ray.cloudpickle import cloudpickle

from aprl_defense.common.utils import create_trainer


def restore_trainer_from_path(path: Path, scenario_name: str, trainer_cls, victim_config=None,
                              config_update=None):
    if victim_config is None:  # Load victim config if not provided, otherwise the provided one is used
        victim_config = get_victim_config(path)

    # Changes to victim config for finetuning
    victim_config['env'] = 'current-env'
    victim_config['env_config']['scenario_name'] = scenario_name

    if config_update is not None:
        victim_config.update(config_update)

    # Restore the trained agent with this trainer
    trainer = create_trainer(trainer_cls, victim_config)
    trainer.restore(checkpoint_path=str(path))
    return trainer


def get_victim_config(path):
    victim_config_path = Path(path).parent / '..' / 'params.pkl'
    victim_config_path = victim_config_path.resolve()
    with open(victim_config_path, "rb") as f:
        victim_config = cloudpickle.load(f)
    return victim_config


def get_checkpoint_file(path: str, specific_folder=False) -> str:
    """For a path to a checkpoint directory return the path the sub-file of the newest checkpoint"""
    if specific_folder:  # A specific folder with checkpoint files is provided
        folder = Path(path)
    else:  # Get the newest subfolder in the checkpoints folder
        checkpoint_folders = Path(path) / 'checkpoints'
        checkpoints = [child.name for child in checkpoint_folders.iterdir() if child.is_dir()]
        checkpoints = sorted(checkpoints)  # If we sort the checkpoints by name, they are in training order
        checkpoint_file = None
        # Get newest checkpoint
        newest = checkpoints[-1]

        folder = checkpoint_folders / newest

    for file in folder.iterdir():
        if not file.suffix == '.tune_metadata' and not file.name == '.is_checkpoint':
            checkpoint_file = file
    # Some sanity checks
    if checkpoint_file is None or not checkpoint_file.is_file():
        raise ValueError(f'Something is wrong with the checkpoint structure')
    checkpoint_file = str(checkpoint_file)
    return checkpoint_file


def log_checkpoint(artifact, checkpoint_dir, current_checkpoint_dir):
    if artifact is not None:
        # Log a new version of the same artifact
        new_artifact = wandb.Artifact(name=artifact.name,
                                      type=artifact.type,
                                      metadata=artifact.metadata)
        new_artifact.add_file(checkpoint_dir / 'params.pkl')
        new_artifact.add_dir(str(current_checkpoint_dir), name=current_checkpoint_dir.name)
        wandb.log_artifact(new_artifact)