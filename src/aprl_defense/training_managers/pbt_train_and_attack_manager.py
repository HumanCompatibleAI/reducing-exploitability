from multiprocessing import Process
from typing import Optional, List

import gin

from aprl_defense.training_managers.base_training_manager import BaseTrainingManager
from aprl_defense.training_managers.pbt_manager import PBTManager
from aprl_defense.trial.settings import TrialSettings, RLSettings


@gin.configurable(name_or_fn="pbt_train_attack")
class PBTTrainAndAttackManager(BaseTrainingManager):
    def __init__(
        self,
        trial_settings: TrialSettings,
        rl_settings: RLSettings,
        override: Optional[str],
        override_f: Optional[str],
        num_ops_list: List[int],
        num_training: int,
        num_attacks: int,
        num_processes: int,
        both_agents: bool = False,
        op_experience_factor: float = 1.0,
    ):
        self.trial_settings = trial_settings
        self.rl_settings = rl_settings
        self.override = override
        self.override_f = override_f
        self.num_ops_list = num_ops_list
        self.num_training = num_training
        self.num_attacks = num_attacks
        self.num_processes = num_processes
        self.both_agents = both_agents
        self.op_experience_factor = op_experience_factor

    def train(self):
        if self.both_agents:
            agents = [0, 1]
        else:
            agents = [0]

        processes = []
        # Perform PBT training
        for it in range(self.num_training):
            for agent in agents:
                for num_ops in self.num_ops_list:
                    p = Process(
                        target=f,
                        args=(
                            self.trial_settings,
                            self.rl_settings,
                            self.override,
                            self.override_f,
                            agent,
                            num_ops,
                        ),
                    )
                    p.start()
                    processes.append(p)
        while True:
            for i in range(len(processes)):
                p = processes[i]
                if p is not None:
                    p.join(0)
                    if p.is_alive():
                        pass  # Process is still going
                    else:
                        print(f"{i} is finished")
                        processes[i] = None
            # Check whether all are done
            if all([p is None for p in processes]):
                break
        print("All processes finished!")


def f(trial_settings, rl_settings, override, override_f, main_id: int, num_ops: int):
    training_manager = PBTManager(
        trial_settings,
        rl_settings,
        override,
        override_f,
        main_id=main_id,
        num_ops=num_ops,
    )
    training_manager.train()
