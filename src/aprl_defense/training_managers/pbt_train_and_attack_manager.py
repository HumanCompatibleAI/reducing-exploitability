import time
from multiprocessing import Process, Queue
from typing import Optional, List, Union

import datetime
import gin

from aprl_defense.training_managers.base_training_manager import BaseTrainingManager
from aprl_defense.training_managers.pbt_manager import PBTManager
from aprl_defense.training_managers.simple_training_manager import AttackManager
from aprl_defense.trial.settings import TrialSettings, RLSettings


@gin.configurable(name_or_fn="pbt_train_attack")
class PBTTrainAndAttackManager(BaseTrainingManager):
    def __init__(
        self,
        trial_settings: TrialSettings,
        rl_settings: RLSettings,
        override: Optional[str],
        override_f: Optional[str],
        num_ops_list: List[int],
        num_training: int,
        num_attacks: int,
        num_processes: int,
        both_agents: bool = False,
        op_experience_factor: float = 1.0,
    ):
        # For this type of multi-job run I would like to have all runs even with the same group name in separate groups, this is why I have a timestamp in
        # addition to the original name as the group name
        now = datetime.datetime.now()
        timestamp = now.strftime("%Y-%m-%d-%H-%M-%S")
        trial_settings.wandb_group += "pbt+attack-" + timestamp
        self.trial_settings = trial_settings
        self.rl_settings = rl_settings
        self.override = override
        self.override_f = override_f
        self.num_ops_list = num_ops_list
        self.num_training = num_training
        self.num_attacks = num_attacks
        self.num_processes = num_processes
        self.both_agents = both_agents
        self.op_experience_factor = op_experience_factor

    def train(self):
        if self.both_agents:
            agents = [0, 1]
        else:
            agents = [0]

        def pbt_training(main_id: int, num_ops: int, q: Queue):
            training_manager = PBTManager(
                self.trial_settings,
                self.rl_settings,
                self.override,
                self.override_f,
                main_id=main_id,
                num_ops=num_ops,
            )
            q.put(training_manager.wandb_id)
            q.put(training_manager.main_policy)
            training_manager.train()

        def attack(adversary_id: int, victim_policy_name: str, victim_artifact: str):
            training_manager = AttackManager(
                self.trial_settings,
                self.rl_settings,
                self.override,
                self.override_f,
                victim_artifact=victim_artifact,
                adversary_id=adversary_id,
                victim_policy_name=victim_policy_name,
            )
            training_manager.train()

        process_queue: List[List[Union[Queue, Process]]] = []
        running_processes = []
        # PBT training processes
        for it in range(self.num_training):
            for agent in agents:
                for num_ops in self.num_ops_list:
                    q = Queue()
                    p = Process(
                        target=pbt_training,
                        args=(agent, num_ops, q),
                    )
                    process_queue.append([p, agent, q])
        for i in range(self.num_processes):
            element = process_queue.pop(0)
            element[0].start()
            running_processes.append(element)

        while True:
            time.sleep(0.1)
            for i in range(len(running_processes)):
                element = running_processes[i]
                if element is None:
                    if len(process_queue) > 0:
                        # Simply start new process
                        new_p = process_queue.pop(0)
                        new_p[0].start()
                        running_processes[i] = new_p
                elif len(element) == 3:  # Training process
                    q: Queue
                    p, agent, q = element
                    p.join(timeout=0)
                    if p.is_alive():
                        pass  # Process is still going
                    else:  # Training process finished -> add attackers, start new process
                        wandb_id = q.get()
                        main_policy_name = q.get()
                        print(f"{wandb_id} is finished")

                        # Add attackers to just finished process to queue
                        attacker_agent_id = 1 - agent
                        for attack_it in range(self.num_attacks):
                            p = Process(
                                target=attack,
                                args=(
                                    attacker_agent_id,
                                    main_policy_name,
                                    wandb_id + ":latest",
                                ),
                            )
                            process_queue.append([p])

                        # Start appropriate number of attacks on this artifact
                        new_p = process_queue.pop(0)
                        new_p[0].start()
                        running_processes[i] = new_p
                else:  # Attack process -> simply get next from queue (if just finished
                    p = element[0]
                    p.join(timeout=0)
                    if p.is_alive():
                        pass  # Process is still going
                    else:  # Attack process finished -> start new process from queue
                        if len(process_queue) > 0:
                            new_p = process_queue.pop(0)
                            new_p[0].start()
                            running_processes[i] = new_p
                        else:
                            running_processes[i] = None

            # Check whether all are done
            if all([p is None for p in running_processes]) and len(process_queue) == 0:
                break
        print("All processes finished!")
